---
type: idea
aliases:
  - 바이브코딩 보안 에이전트
  - Code Trust Agent
  - 코드 신뢰 검증기
  - CodeTrust
author: "[[John]]"
date created: 2026-02-18
date updated: 2026-02-18
tags:
  - type/idea
  - status/inProgress
  - priority/high
  - ai/agents
  - ai/automation
  - dev/python
  - security/analysis
  - security/sandbox
  - project/saas
  - market/korea
  - methodology/cmds
---

# ⭐ Vibe Coding Security Verification Agent

> *"카카오톡 API 비용을 안 받는 개발자가 진짜 선의였을까?"*
> — 4년 전의 의문이 이 기획의 출발점이다.

---

## 1. 원점: 존의 경험

2022년쯤, 크몽에서 온라인 견적서 프로그램을 구매했다. 기능은 괜찮았다. 그런데 하나가 이상했다. 견적서 안에 **카카오톡 발송 기능**이 내장되어 있었는데, 개발자가 카카오 비즈메시지 API 비용을 별도로 청구하지 않았다. 카카오 알림톡 API는 건당 과금이 발생하는 유료 서비스다. 왜 공짜로 넣어줬을까?

당시에는 그냥 넘어갔다. 그러다 직접 코딩을 배우고, Claude에게 해당 프로그램의 코드를 분석시켰다. 결과는 불안했다. **견적서에 입력되는 고객 데이터(이름, 연락처, 금액)가 외부 서버로 전송될 수 있는 구조**였다. 데이터 후킹 가능성. 카카오톡 API 비용을 안 받은 이유가 설명됐다 — 데이터 자체가 수익이었을 수 있다.

이건 내 이야기지만, 나만의 이야기가 아니다.

---

## 2. 문제 정의: 바이브코딩 시대의 신뢰 붕괴

### 바이브코딩이 만든 새로운 위험

2025~2026년, "바이브코딩"이 폭발적으로 성장했다. Cursor, Replit Agent, Claude Code, v0 등으로 **코딩을 모르는 사람도 앱을 만들 수 있는 시대**가 열렸다.

그런데 역설이 있다:

- **코드를 만들 수 있지만, 코드를 읽을 수 없다.**
- AI가 생성한 코드에 보안 취약점이 있어도 모른다.
- 외부에서 가져온 템플릿, 보일러플레이트, npm 패키지에 악성 코드가 있어도 확인할 방법이 없다.

Unit 42(Palo Alto Networks)의 2026년 1월 연구에 따르면, **5개 바이브코딩 도구로 만든 15개 앱에서 69개의 보안 취약점**이 발견됐다. CSO Online은 "바이브코드는 반드시 디버깅하지 않으면 취약점이 도입된다"고 경고했다.

### 바이브코더의 실제 행동 패턴 — 진짜 위험이 터지는 순간

바이브코더의 전형적 작업 흐름을 보면 위험 지점이 명확하다:

1. **유튜브에서 "10분만에 SaaS 만들기" 영상을 본다**
2. **영상이 시키는 대로 터미널에 명령어를 복붙한다** — `npm install`, `pip install`, `npx create-...`
3. **에러가 나면 AI한테 물어보고, AI가 시키는 대로 한다** — `sudo npm install`, `pip install --user`, 환경변수 설정
4. **뭘 설치했는지, 그게 뭘 하는지 전혀 모른 채 다음 단계로 넘어간다**

이게 왜 치명적인가? **OS 보안 시스템은 "사용자가 직접 실행한 것"은 신뢰하기 때문이다.**

- **Windows Defender** — 사용자가 직접 실행한 `npm install`은 간섭하지 않는다. "사용자가 원한 행동"으로 본다.
- **macOS Gatekeeper** — App Store 외부 앱은 경고하지만, 터미널에서 `pip install`한 패키지는 전혀 검사하지 않는다.
- **Linux** — `sudo`를 입력하는 순간 시스템의 모든 문이 열린다.

**핵심 문제: 바이브코더는 코드를 읽을 줄 모르면서, OS가 막아주지도 않는 명령어를 유튜브가 시키는 대로 실행한다.** 이 갭이 공격자의 놀이터다.

### 클라우드 환경의 착각 — "서버니까 안전하다"는 오해

RunPod, Google Colab, GitHub Codespaces 같은 클라우드 개발 환경을 쓰면 내 PC와 격리돼서 직접적인 피해는 없다. 맞다. **하지만:**

- 클라우드 환경에 올린 **API 키**(OpenAI, Stripe, Supabase)는 유출 가능하다
- `.env` 파일에 넣은 **크레덴셜**이 악성 패키지에 의해 외부로 전송될 수 있다
- 클라우드 환경의 **SSH 키, 토큰**이 탈취되면 연결된 모든 서비스가 위험해진다
- AI 에이전트에게 준 **MCP 토큰**이나 **GitHub PAT**가 유출되면 코드 저장소 전체가 뚫린다

격리된 환경이라고 안심하는 순간, 진짜 가치 있는 것(API 키, 크레덴셜)은 이미 노출된다.

### 크몽/프리랜서 마켓의 구조적 문제

한국에서 크몽, 숨고, 위시켓 같은 플랫폼을 통해 외주 프로그램을 구매하는 사람이 늘고 있다. 문제는:

1. **구매자는 코드를 검증할 능력이 없다** — 코딩을 모르니까 외주를 맡긴 거다.
2. **납품된 코드에 백도어가 있어도 알 수 없다** — 내 견적서 프로그램처럼.
3. **크몽은 코드 품질/보안을 검증하지 않는다** — 플랫폼은 거래 중개만 한다.
4. **바이브코딩 결과물도 마찬가지** — AI가 만들어준 코드가 안전한지 누가 보장하나?

### 핵심 질문

> **"내가 설치하려는 이 코드/프로그램이 안전한지, 코딩을 모르는 내가 어떻게 확인할 수 있을까?"**

이게 이 프로젝트가 풀어야 할 문제다.

---

## 3. 아이디어 핵심

**AI 기반 코드 보안 검증 에이전트** — 코딩을 모르는 사용자가 코드나 프로그램을 넣으면, AI가 "이 코드가 뭘 하는지"를 사람 말로 설명해주고, 위험 요소를 찾아 알려주는 서비스.

안티바이러스와 다르다. 바이러스 시그니처를 찾는 게 아니라, **코드의 행동을 분석하고 설명**하는 것이다.

- "이 코드는 당신의 연락처 데이터를 `api.unknown-server.com`으로 전송합니다."
- "이 npm 패키지는 6개월 전에 메인테이너가 바뀌었고, 새 버전에 난독화된 코드가 추가됐습니다."
- "이 프로그램은 백그라운드에서 포트 8443을 열고 외부 연결을 수신합니다."

### 포지셔닝 — 에어백이지, 방탄차가 아니다

**우리는 "100% 안전합니다"라고 말하지 않는다.** 그건 사기다.

제로데이 취약점, 고도로 난독화된 코드, 서플라이 체인 공격 — 100% 막을 수 있는 보안은 존재하지 않는다. 하지만 **에어백은 100% 생존을 보장하지 않아도 장착하지 않는 차는 없다.**

우리의 가치 제안:
- ❌ "이 코드는 100% 안전합니다" (거짓말)
- ✅ **"이 코드의 위험도를 분석해서 판단을 도와드립니다"** (진짜 가치)

**구체적으로:**
- 알려진 위험 패턴의 **80~90%를 탐지**해서 경고
- 판단의 근거(어떤 코드가, 어디서, 뭘 하는지)를 **사람이 읽을 수 있는 언어로** 제공
- "모르겠습니다"도 솔직하게 — 분석 범위와 한계를 항상 명시

**비즈니스 관점에서도 이게 맞다:**
- "100% 안전 보장" → 한 번 뚫리면 신뢰 완전 붕괴 + 법적 책임
- "위험도 분석 + 판단 지원" → 지속 가능한 신뢰 관계 + 사고 시에도 "우리가 경고했다"

---

## 4. 시장 분석

### 기존 보안 솔루션의 한계

| 도구 | 뭘 하는가 | 왜 부족한가 |
|------|----------|------------|
| **Snyk** | 오픈소스 의존성 취약점 스캔 | 커스텀 코드의 악의적 행동은 못 잡음. 개발자용 CLI 도구 — 일반인이 쓸 수 없음 |
| **Semgrep** | 정적 코드 패턴 매칭 | 규칙 작성이 필요. 데이터 흐름 추적 약함. 역시 개발자 전용 |
| **Socket.dev** | npm/PyPI 패키지 공급망 분석 | 패키지만 봄. 전체 프로젝트 코드는 분석 안 함 |
| **VirusTotal** | 파일 시그니처 기반 악성코드 탐지 | 새로 짠 악성 코드는 시그니처가 없어서 통과. 코드 행동 분석 불가 |
| **CodeQL** | 시맨틱 코드 분석 | 학습 곡선이 가파름. GitHub Advanced Security 유료 |
| **npm audit** | 알려진 CVE 체크 | 알려진 취약점만. 악의적 코드, 타이포스쿼팅, 메인테이너 변경 감지 불가 |

**공통적 한계: 모두 개발자를 위한 도구다.** 비개발자가 "이 코드 안전해?"라고 물을 수 있는 서비스는 **존재하지 않는다.**

### 타겟 사용자

**1차 타겟: 바이브코더 & 노코더** (시장 규모 급성장 중)
- Cursor, Replit, Bolt 등으로 코드를 생성하지만 보안 검증 능력이 없는 사람
- 한국만 해도 GPTers 커뮤니티 10만+, 각종 AI 코딩 강의 수강생

**2차 타겟: 크몽/위시켓 외주 구매자**
- 외주 결과물을 검증하고 싶지만 방법을 모르는 소상공인, 스타트업
- 한국 IT 외주 시장 규모 연간 수조 원

**3차 타겟: 비개발자 의사결정권자**
- CTO가 없는 소규모 팀에서 외부 코드를 도입할 때 의사결정 근거가 필요한 대표/PM

---

## 5. 솔루션 아키텍처

### 동작 흐름

```
사용자 입력                     분석 파이프라인                    결과
─────────                     ──────────                     ────
                              ┌─────────────────┐
  ZIP/GitHub URL ──────────►  │  1. 코드 추출    │
  코드 붙여넣기                │  언어 감지       │
  .exe 파일                   │  구조 파싱       │
                              └────────┬────────┘
                                       │
                              ┌────────▼────────┐
                              │  2. 정적 분석    │
                              │  AST 파싱        │
                              │  데이터 흐름 추적 │
                              │  패턴 매칭       │
                              └────────┬────────┘
                                       │
                              ┌────────▼────────┐
                              │  3. AI 코드 리뷰 │
                              │  LLM 행동 분석   │
                              │  의도 추론       │
                              │  한국어 설명 생성 │
                              └────────┬────────┘
                                       │
                              ┌────────▼────────┐
                              │  4. 동적 분석    │  ← MVP 이후
                              │  샌드박스 실행   │
                              │  네트워크 캡처   │
                              │  파일시스템 모니터│
                              └────────┬────────┘
                                       │
                              ┌────────▼────────┐
                              │  5. 보고서 생성  │
                              │  위험도 점수     │
                              │  한국어 요약     │
                              │  조치 권고       │
                              └─────────────────┘
```

### 핵심 설계 원칙

1. **설명이 먼저, 점수는 나중** — "위험도 7.2"보다 "이 코드는 당신의 고객 전화번호를 외부로 보냅니다"가 중요하다.
2. **한국어 네이티브** — 보고서, UI, 알림 모두 한국어. 한국 사용자가 1차 타겟.
3. **Zero Setup** — 회원가입 → 코드 업로드 → 결과 확인. 설치할 것 없음.
4. **솔직한 한계 명시** — "분석 범위: 정적 분석 기준" "난독화된 코드는 탐지율이 낮을 수 있음" 항상 표기.

---

## 6. 실제 사용 시나리오 (UX 플로우)

### 시나리오 1: 바이브코더가 npm install 하기 전

**상황:** 초보자가 유튜브 튜토리얼을 따라 SaaS를 만들고 있다. 영상에서 `npm install some-cool-package`를 치라고 한다.

```
[사용자 화면 — 브라우저 확장 또는 CLI]

$ npm install some-cool-package

┌──────────────────────────────────────────────┐
│  🛡️ CodeTrust — 설치 전 패키지 검사          │
│                                              │
│  📦 some-cool-package@2.1.0                  │
│                                              │
│  ⚠️ 주의 필요 (위험도: 58/100)                │
│                                              │
│  발견된 문제:                                 │
│  🟡 메인테이너가 3주 전에 변경됨              │
│     이전: @trusted-dev (3년간 유지보수)       │
│     현재: @new-unknown-user (활동 이력 없음)  │
│                                              │
│  🟡 새 버전에서 postinstall 스크립트 추가됨   │
│     이 스크립트는 설치 시 자동으로 실행됩니다  │
│     내용: 환경변수를 수집해서 외부로 전송     │
│                                              │
│  🟢 주간 다운로드: 45,000 (안정적)            │
│  🟢 라이선스: MIT                             │
│                                              │
│  💡 권고: 설치하지 마세요.                    │
│     대안: official-cool-package (검증됨)      │
│                                              │
│  [설치 진행] [설치 취소] [상세 보고서 보기]   │
└──────────────────────────────────────────────┘
```

**핵심 UX 원칙:**
- 설치를 **막는 게 아니라** 정보를 주고 **선택하게** 한다
- "환경변수를 수집해서 외부로 전송" — 비개발자도 이해할 수 있는 말
- 대안 패키지를 즉시 제안 → 행동으로 이어지게

### 시나리오 2: 크몽 외주 결과물 검증

**상황:** 소상공인이 크몽에서 주문관리 시스템을 50만원에 외주 맡겼다. ZIP 파일로 결과물을 받았다.

```
[웹 대시보드]

📂 업로드: order-management-v2.zip (분석 중... 약 2분)

┌──────────────────────────────────────────────┐
│  🔍 코드 보안 검증 보고서                    │
│  분석 대상: order-management-v2              │
│  파일 수: 47개 / 언어: JavaScript, Python    │
│  분석 시간: 1분 42초                          │
│                                              │
│  종합 위험도: 🔴 위험 (78/100)                │
│                                              │
│  📌 심각한 문제 2건, 주의 1건                 │
│                                              │
│  1. 🔴 심각 — 고객 데이터 외부 전송           │
│     📄 server/routes/invoice.js:42           │
│     고객 이름, 전화번호, 주문금액을           │
│     api.data-collect.xyz 서버로 전송합니다.   │
│     ⚡ 이 서버는 등록된 사업자 정보가 없습니다│
│     → 이 기능은 정상적인 서비스에 불필요합니다│
│                                              │
│  2. 🔴 심각 — 숨겨진 관리자 백도어            │
│     📄 server/middleware/debug.js:15         │
│     특정 URL(/admin-debug-x7k2)로 접속하면   │
│     인증 없이 모든 데이터에 접근 가능합니다   │
│     → 납품 후에도 개발자가 접속할 수 있습니다 │
│                                              │
│  3. 🟡 주의 — .env 파일 포함됨               │
│     DB 비밀번호, API 키가 코드에 포함되어     │
│     있습니다. 즉시 변경이 필요합니다.         │
│                                              │
│  ✅ 조치 권고                                 │
│  - invoice.js 42번 줄 외부 전송 코드 삭제     │
│  - debug.js 파일 전체 삭제                    │
│  - .env 파일의 모든 비밀번호/키 즉시 변경     │
│  - 개발자에게 해명 요청 권장                  │
│                                              │
│  ⚖️ 분석 한계 고지                            │
│  이 보고서는 정적 분석 기반입니다.            │
│  난독화되었거나 런타임에만 작동하는 코드는    │
│  탐지하지 못했을 수 있습니다.                 │
│                                              │
│  [PDF 다운로드] [개발자에게 공유] [재분석]    │
└──────────────────────────────────────────────┘
```

### 시나리오 3: 클라우드 환경에서 API 키 보호

**상황:** RunPod에서 AI 모델을 돌리고 있다. 여러 패키지를 설치하면서 `.env`에 OpenAI API 키를 넣었다.

```
[CLI 출력]

$ codetrust scan --env

🔍 환경변수 & 크레덴셜 스캔 결과

⚠️ 2개 패키지가 환경변수에 접근합니다:

  1. 🟡 data-preprocessor@1.0.3
     os.environ['OPENAI_API_KEY'] 읽기 → 합리적 사용
     (OpenAI 호출에 사용, 외부 전송 없음)

  2. 🔴 ml-utils-helper@0.9.1
     os.environ 전체 읽기 → 의심
     환경변수 전체를 수집 후 POST 요청 감지
     대상: analytics.ml-tracker.io
     → 이 패키지를 즉시 제거하세요!

💡 권고: API 키는 환경변수 대신 시크릿 매니저 사용을 추천합니다.
```

---

## 7. 제품 형태 분석: CLI vs GUI vs 브라우저 확장

### 각 형태별 장단점

| 형태 | 장점 | 단점 | 타겟 적합도 |
|------|------|------|-----------|
| **CLI 도구** | 개발 워크플로우 자연스럽게 통합, npm/pip 훅 가능, 빠른 개발 | 바이브코더가 CLI 자체를 무서워함, 설치 허들 | ⭐⭐ |
| **웹 대시보드** | 설치 불필요, 접근성 최고, 비개발자 친화적 | 실시간 보호 불가 (사후 분석), 매번 업로드 귀찮음 | ⭐⭐⭐⭐ |
| **브라우저 확장** | GitHub 페이지에서 원클릭, 설치 간편 | npm install 같은 로컬 행동은 가로챌 수 없음 | ⭐⭐⭐ |
| **VS Code/Cursor 확장** | 코딩 중 실시간, 바이브코더가 실제 쓰는 도구에 통합 | 확장 개발 복잡, 에디터별 별도 개발 | ⭐⭐⭐⭐ |

### 결론: MVP는 웹 대시보드, 그다음 VS Code/Cursor 확장

**Phase 1 (MVP):** 웹 대시보드
- 이유: 개발 가장 빠르고, 비개발자 접근성 최고, 어떤 환경에서든 사용 가능
- ZIP 업로드 / GitHub URL / 코드 붙여넣기 → 보고서

**Phase 2:** CLI 도구 (npm/pip 훅)
- `codetrust install express` → 내부적으로 검사 후 npm install
- package.json / requirements.txt 전체 스캔 기능

**Phase 3:** VS Code / Cursor 확장
- 바이브코더가 가장 많이 쓰는 에디터에서 실시간 경고
- 터미널에서 `npm install` 입력 시 자동 인터셉트

**Phase 4:** 브라우저 확장
- GitHub 레포 페이지에서 "🛡️ 보안 스캔" 버튼

---

## 8. 핵심 기능 상세

### 8.1 정적 분석 엔진

단순 패턴 매칭이 아니라, **의심 행동 탐지** 중심으로 설계한다.

**탐지 대상:**
- **외부 통신**: `fetch`, `axios`, `http.request`, `urllib`, `requests.post` 등의 호출 → 대상 URL 추출 → 알려진 API vs 미상 서버 분류
- **데이터 수집**: 파일 읽기(`fs.readFile`, `open()`), 환경변수 접근(`process.env`, `os.environ`), 키 입력 캡처
- **난독화 패턴**: `eval()`, `exec()`, base64 인코딩된 문자열, 동적 import, webpack으로 뭉쳐진 코드의 의심 패턴
- **권한 상승**: `sudo`, 레지스트리 수정, 시스템 서비스 등록, cron/스케줄러 등록
- **크레덴셜 접근**: `.env` 파일 읽기, 환경변수 전체 덤프(`os.environ` 순회), AWS/GCP 크레덴셜 파일 접근
- **의존성 체인**: `package.json`, `requirements.txt`, `pubspec.yaml`의 의존성 → 각 패키지의 메인테이너 변경 이력, 다운로드 수, 최근 업데이트 확인
- **인스톨 스크립트**: `postinstall`, `preinstall` (npm), `setup.py`의 `cmdclass` (Python) — 설치 시 자동 실행되는 코드 특별 감시

**구현 방식 (구체적):**

```
1. Tree-sitter로 AST 파싱
   - tree-sitter-javascript, tree-sitter-python, tree-sitter-typescript
   - AST에서 함수 호출 노드 추출 → 위험 함수 DB와 매칭
   - 데이터 흐름: 변수 할당 → 함수 파라미터 → 반환값 추적

2. Semgrep OSS 규칙 엔진
   - 커스텀 규칙 YAML 작성 (예: "os.environ을 읽은 뒤 HTTP 전송하는 패턴")
   - 기존 Semgrep Registry의 security 규칙 활용 (2,000+ 규칙)
   - 한국 서비스 특화 규칙 추가 (카카오 API, 네이버 API 패턴)

3. 자체 데이터 흐름 추적기
   - "사용자 입력 → 변수 A → 함수 B → HTTP 전송" 경로를 그래프로 시각화
   - Python의 ast 모듈 + 자체 트래커로 구현
   - 핵심: 민감 데이터 소스(env, file read, user input) →
          싱크(http send, file write, exec) 경로 탐지
```

### 8.2 AI 코드 리뷰 (LLM 기반)

정적 분석이 "무엇"을 찾는다면, AI는 **"왜 이게 위험한지"를 설명**한다.

**동작:**
1. 정적 분석에서 플래그된 코드 영역을 LLM에게 전달
2. LLM이 해당 코드의 **의도를 추론**하고 **비개발자용 설명을 생성**
3. 오탐(false positive) 필터링 — "이건 정상적인 로그인 API 호출입니다" vs "이건 사용자 데이터를 알 수 없는 서버로 보냅니다"

**프롬프트 전략:**
- 코드 전체 컨텍스트 + 플래그된 부분 + "이 코드의 의도를 추론하고, 비개발자에게 위험도를 설명하라"
- Few-shot 예시: 정상 코드 vs 악의적 코드 비교
- 한국어 출력 강제 + 전문용어 회피

**모델 선택:**
- Claude 3.5 Sonnet / Claude 4 계열 — 코드 이해력이 가장 높고 한국어 출력 품질 우수
- 비용 최적화를 위해 Haiku로 1차 필터링 → Sonnet으로 2차 정밀 분석

### 8.3 동적 분석 (샌드박스)

정적 분석만으로는 난독화된 코드나 런타임에만 드러나는 행동을 잡을 수 없다.

**샌드박스 실행 환경 (구체적 구현):**

```
Docker + gVisor 아키텍처:
┌─────────────────────────────────────┐
│  호스트 (AWS ECS)                    │
│  ┌───────────────────────────────┐  │
│  │  gVisor (runsc)               │  │
│  │  ┌─────────────────────────┐  │  │
│  │  │  분석 대상 코드 실행     │  │  │
│  │  │  - node/python 런타임   │  │  │
│  │  │  - 제한된 네트워크       │  │  │
│  │  └─────────────────────────┘  │  │
│  └───────────────────────────────┘  │
│                                      │
│  모니터링 레이어:                     │
│  - mitmproxy (HTTPS 트래픽 가로채기) │
│  - eBPF/strace (시스콜 모니터링)     │
│  - OverlayFS (파일 변경 추적)        │
│  - DNS 로거 (모든 도메인 질의 기록)  │
└─────────────────────────────────────┘
```

**네트워크 모니터링 구체 방법:**
- **mitmproxy**: 컨테이너의 모든 HTTPS 트래픽을 프록시 경유 → URL, 헤더, 요청 바디 전부 로깅
- **DNS 로깅**: 컨테이너 내부 DNS를 커스텀 DNS 서버로 강제 → 어떤 도메인에 접근하는지 기록
- **iptables 규칙**: 화이트리스트 외 외부 IP 접근 차단 (npm registry, PyPI 등은 허용)

**캡처 항목:**
- 아웃바운드 네트워크 요청 (URL, 헤더, 바디)
- 파일 I/O (읽기/쓰기/삭제 경로)
- 프로세스 생성 (자식 프로세스 spawning)
- 환경변수/시스템 정보 접근
- 실행 시간 제한: 최대 60초 → 타임아웃 시 강제 종료

### 8.4 공급망 분석 & 패키지 DB

npm, PyPI, pub.dev 패키지의 **신뢰도 평가**:

- 메인테이너 변경 이력 (최근 소유권 이전 = 높은 위험)
- 코드 변경량 대비 버전 점프 (마이너 업데이트인데 코드 90% 변경 = 의심)
- 타이포스쿼팅 탐지 (`lodash` vs `1odash`)
- 인기도 vs 의존성 비율 (다운로드 적은데 의존성이 100개 = 의심)
- postinstall 스크립트 존재 여부 및 내용 분석

**패키지 분석 DB 구축 방안:**

```
데이터 소스:
├── npm Registry API (공개)
│   - 패키지 메타데이터, 버전 히스토리, 메인테이너 변경
│   - 일일 크롤링 (신규/업데이트 패키지 위주)
│
├── PyPI JSON API (공개)
│   - 동일 구조
│
├── Socket.dev / Snyk 공개 데이터
│   - 알려진 악성 패키지 블랙리스트
│
├── GitHub Advisory Database (공개)
│   - CVE/보안 권고
│
├── 커뮤니티 리포트
│   - 사용자가 "이 패키지 수상해요" 신고 → 우선 분석
│   - 분석 결과 다시 DB에 반영
│
└── 자체 분석 결과
    - 스캔한 패키지의 위험도 점수 캐싱
    - 동일 패키지 재분석 방지 (비용 절감)

DB 스키마 핵심:
- package_id, registry(npm/pypi), name, version
- maintainer_history (JSON array)
- risk_score (0-100), risk_factors (JSON)
- last_scanned, scan_result_cache
- community_reports (count, severity)
```

**규모 추정:**
- npm 패키지: ~200만개 (전수 조사 불필요, 인기 상위 10만개 + 신규만)
- PyPI 패키지: ~50만개 (동일 전략)
- 초기 DB: 상위 5만개 패키지 프리스캔 → 나머지는 온디맨드 스캔

### 8.5 보고서 생성

```
┌─────────────────────────────────────────┐
│  🔍 코드 보안 검증 보고서               │
│                                         │
│  종합 위험도: ⚠️ 주의 필요 (62/100)      │
│                                         │
│  📌 발견된 문제 3건                      │
│                                         │
│  1. 🔴 높음 — 고객 데이터 외부 전송      │
│     invoice.js 42번 줄에서 고객 이름과   │
│     전화번호를 api.unknown.kr로 전송합니다│
│     → 이 서버가 정상적인 서비스인지      │
│       확인할 수 없습니다.               │
│                                         │
│  2. 🟡 중간 — 알 수 없는 패키지 사용     │
│     kr-sms-sender 1.2.3 패키지는        │
│     2주 전 메인테이너가 변경되었습니다.  │
│     → 패키지 교체를 권장합니다.          │
│                                         │
│  3. 🟢 낮음 — 에러 로깅 미비            │
│     에러 발생 시 상세 정보가 콘솔에      │
│     노출될 수 있습니다.                 │
│                                         │
│  ✅ 조치 권고                           │
│  - 42번 줄의 외부 전송 코드를 삭제하세요 │
│  - kr-sms-sender를 공식 카카오 SDK로     │
│    교체하세요                           │
│                                         │
│  ⚖️ 분석 범위 및 한계                    │
│  - 정적 분석 + AI 코드 리뷰 기반        │
│  - 난독화 코드 탐지율은 제한적입니다     │
│  - 이 보고서는 참고 자료이며,            │
│    100% 안전을 보장하지 않습니다         │
└─────────────────────────────────────────┘
```

---

## 9. 기술 스택

| 영역 | 기술 | 선택 근거 |
|------|------|----------|
| **백엔드** | Python (FastAPI) | AI/ML 생태계 최강. Semgrep, Tree-sitter 모두 Python 바인딩. 비동기 처리 성능 |
| **정적 분석** | Semgrep OSS + Tree-sitter | Semgrep은 규칙 기반 탐지의 사실상 표준. Tree-sitter는 다국어 AST 파싱 최고 |
| **AI 엔진** | Anthropic Claude API | 코드 이해력 최상위. 한국어 출력 자연스러움. 200K 컨텍스트로 대규모 코드 분석 가능 |
| **샌드박스** | Docker + gVisor | 컨테이너 격리 + 커널 수준 보안. Firecracker도 후보지만 gVisor가 설정 단순 |
| **네트워크 캡처** | mitmproxy | HTTPS 트래픽까지 가로채서 분석. Python 기반이라 통합 용이 |
| **프론트엔드** | Next.js (React) | 한국 개발자 풀 최대. Vercel 배포 간편. SSR로 SEO 확보 |
| **DB** | Supabase (PostgreSQL) | 존이 이미 익숙함. Auth, Storage, Realtime 내장 |
| **인프라** | AWS (ECS + Lambda) | 샌드박스 실행은 ECS, 정적 분석은 Lambda로 서버리스 가능 |
| **큐** | Redis + Bull | 분석 작업 큐잉. 다수 요청 동시 처리 |

---

## 10. 경쟁사 심층 분석

### 직접 경쟁

| 서비스 | 가격 | 타겟 | 핵심 기능 | 우리와의 구체적 차이 |
|--------|------|------|----------|-------------------|
| **Socket.dev** | 무료 (OSS) / Team $100+/월 | 개발팀 | npm/PyPI 공급망 위험 탐지, 설치 시 CLI 경고 | ① 패키지만 분석, 프로젝트 코드는 안 봄 ② 영어 전용 ③ 보고서가 개발자 언어 (CVE ID, CVSS 점수) ④ 비개발자에겐 무용지물 |
| **Snyk** | 무료 ~ Enterprise | DevSecOps 팀 | 의존성 취약점, 컨테이너 스캔, IaC 스캔 | ① CI/CD 파이프라인 통합 전제 — 바이브코더가 CI/CD를 알 리 없음 ② 커스텀 악의적 코드(백도어) 탐지 불가 ③ 한국어 없음 ④ 엔터프라이즈 가격 |
| **npm audit** | 무료 (내장) | npm 사용자 | package-lock.json 기반 CVE 체크 | ① 알려진 취약점만 (0-day 불가) ② 타이포스쿼팅, 메인테이너 변경 등 공급망 공격 감지 불가 ③ 보고서가 기술 용어 |
| **GitGuardian** | 무료 ~ 팀 | 개발팀 | 하드코딩된 시크릿(API 키, 비번) 탐지 | ① 시크릿만 잡음, 코드 행동 분석 없음 ② 악의적 데이터 전송은 탐지 불가 |

### 핵심 차별화 — 왜 우리가 이길 수 있는가

| 차별화 포인트 | 기존 도구 | CodeTrust |
|-------------|----------|-----------|
| **사용자** | 개발자 전용 | **비개발자 퍼스트** |
| **보고서 언어** | CVE-2024-1234, CVSS 7.5 | **"이 코드는 고객 전화번호를 외부로 보냅니다"** |
| **분석 범위** | 패키지 의존성 OR 시크릿 OR 패턴 | **올인원: 정적 + AI + 동적 + 공급망** |
| **한국 시장** | 한국어 미지원 | **한국어 네이티브, 크몽/위시켓 연동** |
| **바이브코더 맞춤** | 고려 안 함 | **npm install 전 인터셉트, Cursor 확장** |
| **신뢰 모델** | "취약점 N개 발견" | **"위험도 분석 + 판단 지원" (에어백 모델)** |

---

## 11. 한국 시장 특화 전략

### 왜 한국 먼저인가

1. **한국어 장벽이 해자(moat)가 된다** — Socket.dev, Snyk는 한국어 진출 우선순위가 낮다. 우리가 한국어 네이티브로 선점하면 최소 2-3년의 시간 벌기.
2. **크몽/위시켓 생태계** — 한국 특유의 프리랜서 마켓플레이스. 이 생태계에 코드 검증을 끼워넣을 수 있다.
3. **GPTers, 노코드 커뮤니티** — 한국의 바이브코딩 커뮤니티가 이미 활발하다. 10만+ 커뮤니티가 초기 사용자 풀.

### 구체적 전략

**1. 크몽/위시켓 코드 검증 서비스**
- 외주 구매자가 납품 받은 코드를 검증하는 SaaS
- 검증 완료 시 "🛡️ CodeTrust 검증 완료" 뱃지 발급
- 크몽에 제안: 플랫폼 내 코드 검증 기능 내장 (B2B)
- **탤런트뱅크/프리랜서 플랫폼과도 동일 전략**

**2. 한국 서비스 특화 탐지 규칙**
- 카카오 비즈메시지 API 패턴 (존의 실제 경험!)
- 네이버 클라우드 API, NHN 토스 결제 API
- 한국 SMS 발송 API (알리고, 문자나라 등)
- 이 규칙들은 글로벌 도구에는 절대 없다

**3. 한국어 마케팅**
- 크몽 인기 프로그램 5개 분석 → 결과 콘텐츠 (블로그/유튜브)
- "당신이 크몽에서 산 프로그램, 안전할까?" — 바이럴 콘텐츠
- GPTers 커뮤니티 베타 테스트 → 입소문

**4. 글로벌 확장 경로**
- 한국에서 PMF 검증 → 일본 (유사한 프리랜서 마켓 구조, 클라우드워크스/랜서즈)
- → 영어권 (Product Hunt 런칭)
- 핵심 기술은 언어 무관, UI/보고서만 현지화

---

## 12. 개발 로드맵

### Phase 0: 2주 MVP — 진짜 최소한 (Week 1-2)

> **목표: "코드를 넣으면 위험한지 아닌지 한국어로 알려준다"를 증명**

**Week 1:**
| 일 | 작업 | 구체적 산출물 |
|----|------|-------------|
| 1-2 | FastAPI 서버 + Supabase 연동 | 파일 업로드 API, 사용자 인증 |
| 3-4 | Semgrep 커스텀 규칙 10개 작성 | 외부 통신, env 접근, eval/exec, postinstall |
| 5 | Claude API 연동 | 정적 분석 결과 → 한국어 설명 변환 프롬프트 |

**Week 2:**
| 일 | 작업 | 구체적 산출물 |
|----|------|-------------|
| 1-2 | Next.js 프론트엔드 | 업로드 → 로딩 → 결과 페이지 (3페이지) |
| 3-4 | 보고서 UI | 위험도 점수 + 한국어 설명 + 조치 권고 |
| 5 | 실제 테스트 | 크몽 견적서 프로그램으로 분석 시연 |

**2주 MVP 산출물:**
- 웹페이지에 ZIP 업로드 → 30초 후 한국어 보고서
- JS/Python 정적 분석 (Semgrep 10개 규칙)
- Claude가 생성한 자연어 설명
- 위험도 점수 (0-100)
- **이것만으로 데모 가능, 투자자/사용자에게 보여줄 수 있다**

### Phase 1: 제대로 된 MVP (Week 3-8)

| 주차 | 작업 |
|------|------|
| 3-4 | Semgrep 규칙 50개로 확대, Tree-sitter AST 분석 추가, 데이터 흐름 추적 |
| 5-6 | 패키지 분석 모듈 (npm/PyPI 메타데이터 조회, 메인테이너 변경 탐지) |
| 7 | 대시보드 고도화 (분석 히스토리, PDF 다운로드, 공유 링크) |
| 8 | 베타 테스트 (GPTers 커뮤니티, 지인 바이브코더 20명) |

### Phase 2: 동적 분석 + 유료화 (Week 9-20)

| 주차 | 작업 |
|------|------|
| 9-12 | Docker/gVisor 샌드박스 구축, mitmproxy 네트워크 캡처 |
| 13-16 | 동적 분석 결과를 기존 리포트에 통합, 네트워크 트래픽 시각화 |
| 17-18 | 유료 플랜 런칭, 결제 연동 (Toss Payments) |
| 19-20 | CLI 도구 출시 (npm/pip 훅) |

### Phase 3: 플랫폼화 (6개월)

- 크몽/위시켓 API 연동 → 외주 결과물 자동 검증
- VS Code / Cursor 익스텐션 → 코딩 중 실시간 검증
- 브라우저 익스텐션 → GitHub 레포 페이지에서 원클릭 분석
- .exe/.dmg 바이너리 분석 (디컴파일 + 행동 분석)
- 팀 기능 (조직 대시보드, 히스토리)

---

## 13. 수익 모델 상세

### 프리미엄 티어 설계

| 플랜 | 가격 | 기능 | 타겟 |
|------|------|------|------|
| **무료** | 0원 | 월 5회 분석, 정적 분석만, 기본 보고서, 1개 프로젝트 | 가벼운 체험, 바이럴 |
| **Starter** | 월 9,900원 | 월 30회 분석, 정적 + AI 분석, 패키지 신뢰도 체크, 분석 히스토리 | 개인 바이브코더 |
| **Pro** | 월 29,000원 | 무제한 분석, 동적 분석 포함, 상세 보고서, PDF 다운로드, CLI 도구, API 접근 | 프리랜서, 파워 사용자 |
| **Team** | 월 99,000원 | Pro + 팀 대시보드, 5인까지, 크몽/위시켓 검증 뱃지 발급, 우선 지원 | 소규모 개발팀, 에이전시 |
| **Enterprise** | 협의 | 온프레미스, 커스텀 규칙, SLA, 전담 매니저 | 대기업, 관공서 |

### 가격 설정 근거
- **9,900원**: 넷플릭스 기본요금 수준. "안전 확인 한 번에 330원" 프레이밍
- **29,000원**: ChatGPT Plus와 동일 가격대. AI 도구에 이미 이 가격을 내는 사용자층
- **99,000원**: CTO 없는 스타트업의 월 보안 비용으로 매우 저렴

### 부가 수익원

| 수익원 | 모델 | 예상 규모 |
|--------|------|----------|
| **크몽/위시켓 검증 뱃지 B2B** | 플랫폼이 구매 → 거래 시 자동 검증 | 건당 1,000-3,000원 × 수만 건/월 |
| **바이브코딩 교육 제휴** | 교육 플랫폼에서 수강생 코드 자동 검증 | 월정액 B2B |
| **API 사용량 과금** | 다른 서비스에서 CodeTrust API 호출 | 건당 100-500원 |
| **보안 컨설팅 연결** | 심각한 문제 발견 시 전문가 매칭 | 수수료 |

---

## 14. 리스크와 대응

| 리스크 | 심각도 | 대응 |
|--------|--------|------|
| **LLM 할루시네이션** — AI가 없는 위험을 만들어냄 | 높음 | 정적 분석 결과를 근거로만 설명 생성. AI 단독 판단 금지. "AI가 추론한 부분"을 명시적으로 표기 |
| **오탐(False Positive)** — 정상 코드를 위험으로 판단 | 높음 | 화이트리스트 DB 구축 (카카오 SDK, Firebase 등 정상 외부 호출). 사용자 피드백 루프로 지속 개선 |
| **미탐(False Negative)** — 악성 코드를 놓침 | 치명 | "100% 안전 보장"을 **절대** 하지 않음. 보고서에 "분석 범위와 한계"를 항상 명시. 동적 분석으로 커버리지 확대. **에어백 포지셔닝** — 있는 것과 없는 것의 차이를 강조 |
| **고도 난독화/제로데이** — 탐지 자체가 불가능한 공격 | 치명 | 솔직하게 인정. "이런 유형은 탐지가 어렵습니다"를 보고서에 명시. 동적 분석(샌드박스)으로 행동 기반 탐지 보완. 커뮤니티 리포트 시스템으로 집단 지성 활용 |
| **경쟁사 진입** — Snyk/GitHub이 비개발자 타겟 확장 | 중간 | 한국어/한국 시장 특화로 선점. 크몽 연동 같은 로컬 경쟁우위. 빠른 실행이 핵심 |
| **비용** — Claude API 호출 비용 | 중간 | Haiku로 1차 필터링, Sonnet은 정밀 분석만. 캐싱 적극 활용 (동일 패키지 재분석 방지). 패키지 DB 프리스캔으로 반복 호출 제거 |
| **법적 이슈** — 타인 코드 분석의 저작권 | 낮음 | 보안 분석은 공정 이용 범위. 분석 결과만 저장, 원본 코드는 분석 후 삭제 정책 |

---

## 15. 즉시 실행 가능한 다음 액션

### 이번 주

- [ ] Semgrep 설치하고 크몽에서 구매했던 견적서 프로그램 실제 분석해보기
- [ ] Claude API로 분석 결과 → 한국어 보고서 변환 프롬프트 프로토타이핑
- [ ] 도메인 확보: `codetrust.kr` or `codesafe.kr` or `codecheck.kr` 확인

### 다음 2주 (2주 MVP)

- [ ] FastAPI + Supabase 프로젝트 뼈대 세팅
- [ ] Semgrep 커스텀 규칙 10개 작성 (외부 통신, 데이터 수집, 난독화)
- [ ] Claude API 연동 → 자연어 보고서 생성 파이프라인
- [ ] Next.js 랜딩 페이지 + 업로드 UI + 결과 페이지
- [ ] **크몽 견적서 프로그램으로 실제 시연 데모 제작**

### 1개월 내

- [ ] Phase 1 MVP 완성 (정적 분석 + AI 보고서 + 패키지 분석)
- [ ] GPTers 커뮤니티에 베타 테스트 공개
- [ ] 크몽 인기 프로그램 5개 분석 → 결과 콘텐츠 제작 → 마케팅

---

## 관련 노트

- [[CMDS Guide]]
- [[AI Agent 개발]]
- [[크몽 견적서 프로그램 분석]]

---

> *"코드를 읽지 못하는 시대에, 코드를 읽어주는 서비스."*
> 이것이 이 프로젝트의 한 줄 정의다.
>
> *"100% 막겠다"가 아니라 "판단을 도와드리겠다" — 이것이 우리의 약속이다.*
