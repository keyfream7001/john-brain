---
type: daily
aliases: ["AI 활용 일지 2026-02-18"]
author: "[[John]]"
date created: 2026-02-18
tags: [type/daily, status/completed, ai/automation, ai/agents, project/app, methodology/workflow, priority/high]
status: completed
---

# 2026-02-18 AI 활용 일지 (강의자료용)

## 1) 오늘의 핵심 한 줄
존과 웬디는 “바이브코딩 보안 검증” 아이디어를 실제 사업기획 문서로 확장했고, 동시에 자동화 루틴(앱빌더 요청 감시)을 안정적으로 운영했다.

## 2) 주제별 작업 상세

### A. 보안 아이디어 → 사업기획 전환
- 출발점: 존의 실제 견적/외주 경험에서 나온 문제의식
- 문제 정의:
  - 비개발자도 AI 코딩 도구를 쓰며 `npm install`, `pip install`을 무심코 실행
  - OS 보안(Defender/Gatekeeper)은 "사용자가 직접 실행"한 행위는 구조적으로 막기 어려움
  - 클라우드 실행 환경(RunPod/Colab)은 로컬 격리는 되지만 키/크레덴셜 유출 위험은 남음
- 기획 포지셔닝:
  - “100% 차단”이 아닌 “위험도 분석 + 실행 전 판단 지원”
  - 비유: 에어백(사고를 0으로 만들진 못하지만 피해를 줄임)
- 산출물(Obsidian 100 Theme):
  1. `⭐ Vibe Coding Security Verification Agent - Idea & Execution Plan.md`
  2. `⭐ CodeTrust - Business Plan.md`

### B. 문서 운영/복구 이슈 대응
- 이슈: 문서 작성 중 기존 파일 덮어쓰기 실수 발생
- 대응: 세션 트랜스크립트 기반으로 내용 복구 후, 문서를 별도 파일로 분리
- 결과: 데이터 손실 없이 구조 개선 완료
- 실무 교훈:
  - “별도 메모” 요청 시 무조건 새 파일 생성
  - 중요한 문서 작업 전 백업/분기 습관화

### C. 모델 운영 및 협업 방식 정리
- 확인: opus 4.6은 이미 적용 상태
- 운영: 서브 에이전트 호출 시 GPT(codex) 대신 opus 4.6을 명시해 톤/품질 일관성 확보
- 목적: 대화체 품질 유지, GPT 느낌 과다 노출 방지

### D. 자동화 운영(10고개 앱빌더)
- 루틴: 2분 간격 heartbeat 기반 pending 요청 확인
- 방법:
  - `node tmp/check_pending.js`
  - Authorization Bearer 헤더로 API 체크
- 결과: `NO_REQUESTS` 반복 확인(신규 요청 없음)
- 의미: 야간에도 서비스 모니터링 루틴은 정상 작동

### E. 커뮤니케이션/브랜딩 대화
- 존 소개 문구 정리: 실행력·연결력·책임감 중심의 인물 묘사
- 웬디 자기소개 정리: 리서치/정리/개발보조/운영 자동화에 강한 AI 비서 포지션
- 추가 응대: 간단 수학 질문(A×B)을 사용자의 이해 수준에 맞춰 재설명

## 3) 오늘의 성과
- 아이디어 단계에서 사업기획 단계로 문서화 완료
- 파일 복구/분리 경험으로 문서 운영 안전성 향상
- 앱빌더 요청 감시 자동화 정상 유지

## 4) 오늘의 리스크와 대응
- 리스크: 문서 덮어쓰기
- 대응 원칙(재발 방지):
  1. 기존 파일 보존 우선
  2. 신규 요청은 신규 파일
  3. 트랜스크립트 복구 경로 확보

## 5) 내일 액션 제안
1. CodeTrust 랜딩용 1페이지 메시지(문제→해결→신뢰) 작성
2. 위험도 평가 기준표(예: 패키지 출처/권한/네트워크 호출) 초안 설계
3. 앱빌더 신규 요청 발생 시 즉시 서브에이전트 생산 파이프라인 연결

## 6) 강의용 인사이트 포인트
- AI 시대 보안은 “차단”보다 “판단 보조”가 시장 적합도가 높다.
- 자동화는 화려함보다 “꾸준한 체크 루틴”이 핵심이다.
- 문서 실수는 시스템화(분리 저장/복구 루트)로 자산으로 전환할 수 있다.
